#### 1.Arrays.sort实现原理和Collections.sort实现原理.
答：Arrays.sort()方法，如果数组长度大于等于286且连续升序和连续降序性好的话，就用归并排序，如果大于等于286且连续性不好的话就用双轴快速排序。如果长度小于286且大于等于47的话就用双轴快速排序，如果长度小于47的话就用插入排序.而Collections.sort实际上就是通过toArray方法转换成数组，然后调用TimSort方法，而不会调用LegacyMergeSort方法，即传统归并方法，而TimSort方法的核心思想就是找到数组中的有序子数组，将无序的单独出来排序，最后通过binarysort方法归并合成一个新数组，通过asList转换成集合返回。
#### 2、foreach和while的区别(编译之后)  
答：foreach 一次读取全部内容，while读一次显示一次，对于大数据量的操作建议使用while。 
#### 3、线程池的种类，区别和使用场景   
答：常见的有四种，这四种都是通过Executors静态工厂创建的，newCacheThreadPool,核心线程数初始化为0，最大线程数为Integer的最大值，非核心空闲线程的存活时间为60s,队列使用的是零缓存队列，任务来的时候直接给线程执行，不会阻塞,使用场景：执行时间短的异步任务。newFixThreadPool核心线程数等于最大线程数，其实最大线程数并没有多大作用，因为队列使用了LinkedBlockingQueue无界队列，所以当核心线程数小于任务数的时候，没有被执行的任务全部放在队列里，如果任务量足够大，就可能撑爆内存，非核心空闲线程的存活时间为0s，使用场景：执行时间长的任务,newScheduledThreadPool，周期线程池，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0s,workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列,使用场景为周期性执行的任务，newSingleThreadExecutor，核心线程数和最大线程数都为一，非核心空闲线程的存活时间为0s,队列使用的是LinkedBlockingQueue无界队列，使用场景为一个一个的任务要有序执行。
#### 4、分析线程池的实现原理和线程的调度过程
答：线程池有什么好处？我们为什么要用线程池？线程的创建和销毁是很耗资源的，这就希望线程能够被很好的管理、复用。所以线程池的作用就出来了，分别是：减少资源的损耗;提高响应速度,避免了线程创建和销毁不要的时间;方便统一管理线程。<br/>
线程池的实现原理和调度线程的过程：线程池的创建，会初始化5到7个参数（核心线程数，最大线程数，线程存活时间，存活时间单位，队列类型，拒绝策略类型（四种：抛异常、默认会选择这种策略；直接丢弃提交过来的任务、不处理；直接让调用方调用，不经过线程池；丢弃最老的任务，也就是队列的头元素，执行提高过来的第一个任务），线程工厂）。</br>
线程池的执行（任务）：也就是线程池的实现原理，可以调用submit或者execute方法，submit方法底层就是调用execute方法，不过submit方法会返回一个FatureTask对象，而execute不会有返回值，这个对象调用get方法如果返回值是null,则说明任务执行完成。而execute方法的底层是怎么实现的呢？任务提交过来的时候(先打住一下，任务其实就是一个Runnable,执行线程只不过封装了这个任务。执行的时候调用runWorker方法,也就是runworker方法调用了任务的run方法，回来再细说这个worker类和runworker方法。),先判断任务数是否小于核心线程数，如果小于核心线程数，那么就创建一个线程扔到线程池中（如何创建？就是调用addWorker方法，回头再细说），如果大于核心线程数，并且队列没有满（我们先假设是有界队列），那么将任务存放到队列中，如果队列满了，但任务数没有超过最大线程数，那么就创建一个线程，放到线程池（HashSet存放一个个Worker，执行线程）中，如果任务超过最大线程数，那么就进行四种拒绝策略的其中一种，默认是抛异常。</br>
线程池的关闭：有两种关闭线程池的方法，分别是shutdown和shutdownNow方法。区别在哪里呢？shutdown方法分两步，先是设置线程的状态为shutdown,这个值是0向右移动29高位，这种状态会让执行线程不接受提交过来的任务，但是会执行队列里及之前的任务；然后是对空闲线程执行interrupt方法。如何判断是否为空闲非核心线程呢？空闲非核心线程一般不会上锁的，核心线程会上锁，所以只要获取是否已经上锁便可知道该线程是否为空闲非核心线程。什么是空闲非核心线程呢？空闲非核心线程就是worker的task属性为null,也可以理解为没有任务去执行，但是还存活在线程池中的非核心线程，我们知道核心线程一般不会被销毁，除非调用shutdownNow方法或者设置允许核心线程超时为true，这时候就可能被销毁。而shutdownNow方法是先设置线程状态（有五种，这个下面细说）为stop，stop的值为1先左移动29位，这种状态线程不接受提交过来的任务，并立即不处理所有的任务。然后让线程池里所有的执行线程调用interrupt方法。</br>
上面已经说完线程池的实现原理和线程的调度过程，下面主要讲一下细节上的:</br>
先说worker类，worker类里面的封装有task任务，执行线程，状态为负一，表示上锁，其他线程获取不到这个worker，还有一个run方法，里面调用了task的run方法。</br>
addworker方法，主要的是判断线程池的状态，线程池的容量及核心数，如果线程池的状态为Running，并且任务数小于线程池的容量或者小于线程数的核心线程数，那么就是让workers,也就是hashSet里面add一个worker。</br>
runWorker方法，获取worker的属性任务，然后调用任务的run方法。</br>
getTask方法，判断是都允许核心线程数超时或者当前任务数大于核心线程数，如果是，则调用阻塞队列的poll方法，否则则调用阻塞队列take方法。</br>
线程池的五种状态：分别是running(可接收提交的任务，执行线程可处理任务，调用shutdown方法进入shutdown状态，调用shutdownNow方法会进入stop状态)，shutdown(不可接收提交的任务，执行线程可处理任务，调用shutdownNow方法会进入stop状态),stop(不可接收提交的任务，执行线程不可处理任务，),tidying（当stop状态的执行线程数为null并且队列没有任务时，调用tryTerminate方法进入terminated状态）,terminated（对执行线程和队列任务会回收完毕）.

#### 5、线程池如何调优 
我们为什么要调优线程池？就是在任务并发处理的时候，让用户在获取数据少等待。一般来说，用户如果超过三秒或者是五秒之内，页面还没有完全加载完成，就会关闭页面。如果让用户有一个很好的体验，建议在2秒之内。所以性能优化方面（这里先特指后台上的线程池）必须要做足功课。线程池调优无非是设置线程池初始化时的那几个参数。</br>
核心线程数  = （并发数的范围）* 单个任务的处理时间。如果一秒钟并发的个数为500到1000个，每个任务的处理完成平均时间为0.1s,那么核心线程数设置为50到100
之间，建议设置为75个到80个。</br>
队列容量：队列常见的有无界队列、有界队列、零缓存队列等。不建议选择无界队列。因为任务进入队列会等待，而且处理的时间无法准确的把握，等待的时间就会在2s或者3s的基础上叠加。建议选择有界队列或者零缓存队列（任务不会在队列中等待，直接提交给线程处理）。如果让等待时间为1s后提交到线程中处理。那么个数和核心线程数相等。75到80之间。任务等待的时间越长，用户叠加等待的时间也就越长，建议在是使用队列的时候，队列容量越小越好。</br>
最大线程数 = （最大并发任务数-队列里的任务数）* 任务平均处理时间。如果使用零缓存队列，队列的任务数为0，最大并发任务数（每秒钟）假设为1000，任务平均处理时间为0.1s,那么最大线程数为100。当然如果硬件允许的情况下，可以设置再大一些。</br>
线程存活时间一般为60s，这个默认值大小就可以。</br>
拒绝策略：一般默认是抛拒绝执行异常，如果业务允许的话，也可以选择其中的不处理或者其他。</br>
最后较重要的是硬件方面，任务分发等。硬件不行升级硬件。任务分发不合理再重新调整权重。</br>

#### 6、线程池的最大线程数目根据什么确定   
公式：线程池的最大线程数 = （最大并发任务数 - 队列容量） * 任务平均响应时间。如果使用零缓存队列，队列容量为0.

#### 7、动态代理的几种方式（如何实现？缓存？字节码？反射机制还是fastClass机制？）
1、动态代理也称运行时增强技术，是spring框架的aop模块的实现原理，动态代理方式我了解的有：jdk动态代理，cglib动态代理，javassist动态代理。</br>

jdk动态代理的代理类必须实现invacationHandler接口，重写invoke方法，获取最终代理类是通过调用Proxy的静态方法newProxyInstance，传入三个参数，分别是目标类的类加载器，目标类的接口数组，和代理类的对象。</br>

cglib:cglib动态代理的代理类实现MethodInterceptor接口，重写intercept方法，获取最终代理类过程是创建一个增强器，然后设置目标类，设置拦截对象，最后调用增强器对象的create方法返回一个代理类。</br>

缓存：它们都将数据以key-value的形式存在缓存中，获取代理类对象一般先判断缓存中是否存在，如果不存在才通过方法反射（jdk动态代理）或者方法索引（cglib ）的方式得到。</br>

字节码底层：cglib是继承目标类和实现工厂接口，jdk动态代理是继承Proxy类和实现目标类的接口。它们最重要的相同点是最终代理类的最终目标方法会调用各自的拦截方法，invoke或者intercept方法。

反射机制还是fastClass机制：cglib的fastClass机制是对目标类的方法设置索引，然后通过索引直接调用目标类的方法。这样的好处是比jdk动态代理通过对目标类方法的反射，即调用Class.forName(xxx).getMethod(xxx)调用目标类的方法要快一些。</br>

#### 8、HashMap的并发问题  
分析地址：https://coolshell.cn/articles/9606.html </br>
当多条线程同时存取操作hashMap时，就可能会出现infinite loop (死循环)，就是当线程之间挂起和执行的链表的指向形成一个环状，就会出现死循环，这个情况出现不是特别明显，是一个隐性的bug,死循环有一个很致命的缺点，就是会让cpu飙升，最后有可能会出现宕机的情况，解决这一问题用hashtable替换或者concurrentHashMap(推荐)替换，或者是使用工具类的包装器，也就是Collections.synchronizedMap()。</br>
HashMap死循环演示</br>
假如有两个线程P1、P2，以及链表 a=》b=》null</br>
1、P1先执行，执行完"Entry<K,V> next = e.next;"代码后发生阻塞，或者其他情况不再执行下去，此时e=a，next=b</br>
2、而P2已经执行完整段代码，于是当前的新链表newTable[i]为b=》a=》null</br>
3、P1又继续执行"Entry<K,V> next = e.next;"之后的代码，则执行完"e=next;"后，newTable[i]为a《=》b，则造成回路，while(e!=null)一直死循环</br>

#### 9、了解LinkedHashMap的应用吗  
LinkedHashMap继承HashMap，也就是在HashMap的基础上进一步封装，HashMap是无序的，LinkedHashMap是有序的，因为在HashMap的基础上添加一个双向链表维护，有序迭代可分为访问顺序和插入顺序迭代，一般默认的是插入顺序迭代元素，即属性accessOrder在LinkedHashMap构造函数里设置为false，访问（调用get或者put方法）顺序的意思是：只要访问过的元素，先删除，即remove,然后add到双向链表的尾部，迭代的时候会从尾部到头部的顺序依次迭代。
